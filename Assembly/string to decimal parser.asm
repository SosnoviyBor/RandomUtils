; ---------------------------------------------------------------------------------
; Предназначение: Парс стринга в десятичное число
; Вход:
; BH <- Длинна стринга (1-3)
; SI <- Адрес начала стринга
; Выход:
; AX <- результат, десятичное число
; ---------------------------------------------------------------------------------
proc string2dec
    push cx
    mov ax, 0   ; Результат
    mov cx, 0   ; Буфер для числа
    Str_parser:
        mov al, [si]    ; Считываем чар из стринга

        ; Проверка на конец стринга
        cmp al, 0dh     ; 0dh = "Enter"
        je no_error

        ; Проверяем, цифра ли это
        cmp al, "0"
        jb error
        cmp al, "9"
        ja error
        sub al, 30h     ; Конвертируем чар в цифру

        ; Увеличиваем число в зависимости от его разряда
        cmp bh, 3
        je mul_by_100
        cmp bh, 2
        je mul_by_10
        jmp str_continue

        mul_by_100:
        mov dx, 10d
        mul dx
        mul_by_10:
        mov dx, 10d
        mul dx

        str_continue:
        add cx, ax      ; Сохраняем число в буфер
        inc si          ; Двигаем указатель на следующий чар
        dec bh          ; BH == 0 : Конец
        jnz Str_parser  ; BH != 0 : Повтор
    mov ax, cx

    ; Искусственное ограничение числа до 255
    ; Оно необязательно, но я лучше себя заранее обезопашу от возможных трудностей...
    ; ...с 2-байтными регистрами в будущем
    cmp ax, 255d
    jna no_error
   
    ; Ашипка и терминация
    error:
    mov bx, 2
    call error_manager

    no_error:
    mov ax, cx
    pop cx
    ret
endp string2dec

